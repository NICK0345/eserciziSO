a) si ha trashing quando ci sono talmente tanti processi in memoria principale che i frame per questi non sono sufficienti, e di conseguenza, essendo tra di loro in competizione per ottenere le risorse, se li ruberanno a vicenda, andando ad aumentare il numero di page fault e quindi rallentando il sistema. Sospendendo un processo si fa si che i frame da questo occupati possano essere utilizzati da altri processi, che quindi avendo abbastanza risorse per tutti non si ruberanno piu' i frame; quindi riusciranno a terminare lasciando liberi i frame che potranno poi essere usati dal processo che era stato sospeso. Chiaramente allo stesso modo di come se ne puo' bloccare uno solo, se ne possono bloccare di piu.
b) Li sposta nella coda di waiting; lo scheduler quando dovra' scegliere quale processo avviare, scegliera' tra quelli in coda ready, quindi di fatto, il processo rimarra' bloccato
c) si possono usare sia crittografia simmetrica che asimmetrica. Nel primo caso la capability verra' cifrata con una chiave che solo il kernel / server conosce e quindi per il processo che la deterra' saranno solo una lista di bit. Nel secondo caso invece chi cifra usera' la propria chiave pubblica, cosi' che solo lui (allo stesso modo del primo caso) potra' riuscire a decifrare la capability. Per questioni di semplicita' ed efficienza viene tuttavia usata la crittografia simmetrica
d) Se con RAID1 si rompe uno dei due dischi, i dati rimangono accessibili sin da subito. Se con RAID5 si rompe uno dei due dischi, prima di poter riaccere ai dati, dovro' ricostruirli, in un sistema con RAID5 e due dischi fisici, i dati vengono cosi' divisi:
    S0      P0
    P1      S1
Se uno dei due dischi si rompe, io saro' ancora in grado di poter ricalcolare i dati che erano memorizzati "in chiaro" nel disco rotto, ma saro' costretto a fare il not di ogni bit della partizione di parita'.