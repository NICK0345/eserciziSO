c1:
monitor bitcond{
    int bits;
    int active;
    int int_length = 32;
    condition is_set[int_length];
    condition waiting;

    procedure INIT{
        bits = 0;
        active = false;
    }

    procedure entry set(int bit2set){
        bits |= bit2set;
        for(i=0; i<int_length; i++)
            if(bit2set & 2**i==1)
                SIGNAL(is_set[i]);
    }
    procedure entry unset(int bit2unset){
        bits &= ~bit2unset;
    }
    procedure entry statuswait(int bit2wait){
        if(active>0)
            WAIT(waiting);
        active++;
        int i = 0;
        while(i<int_length){
            if(bit2wait & 2**i==1 && bits&2**i==0){
                wait(is_set[i]);
                i=-1;
            }
            i++;
        }
        active--;
        SIGNAL(waiting);
    }
}
c2:
    Queue waits = ();
    int sum = 0;
    sem_t mutex(1);
    void sumstop(int v){
        mutex.P();
        sem_t wait(1);
        q.enqueue(wait);
        sum+=v;
        wait.P();
        mutex.V();
    }
    void sumgo(){
        mutex.P();
        while(!q.isEmpty()){
            sem_t sem = q.dequeue();
            sem.V();
        }
        int res = sum;
        sum = 0;
        mutex.V();
        return res;
    }
g1:

g2:
    a) bootstrapping
    b) ???
    c) ???
    d) le system call vengono eseguite in kernel mode e sono direttamente integrate nel kernel; le funzioni di libreria invece vengono eseguite in user mode.